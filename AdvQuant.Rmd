---
title: "Droughtnet Group 3"
authors: "Priscilla, Garrett & Emma"
output: html_document
date: "2023-01-17"
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
# Install and Load Packages
```{r}
install.packages("tidyverse")
install.packages("readxl")
install.packages("janitor")

library(tidyverse)
library(readxl)
library(janitor)
library(dplyr)
```
# Import data and bind years
```{r}
Spring_2020_raw <- read_excel("Spring 2020 - Percent Cover - Raw Data DNET.xlsx", sheet = "Sheet1", col_names = FALSE)
Spring_2021_raw <- read_excel("Spring 2021 - Percent Cover - Raw Data DNET.xlsx", sheet = "Sheet1", col_names = FALSE)
Spring_2022_raw <- read_excel("Spring 2022 - Percent Cover - Raw Data DNET.xlsx", 
    sheet = "Sheet1", col_names = FALSE)

Spring_Data_raw <- bind_rows(Spring_2020_raw, Spring_2021_raw, Spring_2022_raw)
```
# Rename columns and filter dates
```{r}
Spring_Data_raw <- Spring_Data_raw %>% row_to_names(row_number(1)) %>% 
  rename(Transect = `Transect #`,  Hits = `# Hits`) %>% 
  filter(Date != "Date" & Date != "mm/dd/yy" & Date != "NA")
```
#Check for NA's and misinputed Data. NA's fixed on Intermediate file
```{r}
unique(Spring_Data_raw$Date)
unique(Spring_Data_raw$Block)
unique(Spring_Data_raw$Plot)
unique(Spring_Data_raw$Treatment)

#Distance of 53 is a wrong input, changing to 3
Spring_Data_raw <- Spring_Data_raw %>% 
  mutate(Distance = ifelse(as.numeric(Distance) == 53, 3, as.numeric(Distance)))
unique(Spring_Data_raw$Distance)

```
#Change Column Types
```{r}
Spring_Data_raw <- Spring_Data_raw %>%
  mutate(Block = as.numeric(Block)) %>% 
  mutate(Plot = as.numeric(Plot)) %>% 
  mutate(Transect = as.numeric(Transect))

Spring_Data_raw <- Spring_Data_raw %>% 
  mutate(Block = factor(Block)) %>% 
  mutate(Plot = factor(Plot)) %>% 
  mutate(Treatment = factor(Treatment)) %>% 
  mutate(Region = factor(Region)) %>% 
  mutate(Transect = as.numeric(Transect)) %>% 
  mutate(Distance = as.numeric(Distance)) %>%
  mutate(Hits = as.numeric(Hits)) %>% 
  mutate(Date = as.numeric(Date)) %>% 
  mutate(Date = as.Date(Date, origin = "1899-12-30"))
```
# Standardize Code Names
## Create a file of unique species codes to be corrected
###This below should be removed I think, broke my code -Garrett
```{r}
Spring_Data_raw$Code %>% unique() %>% sort() %>% write.csv(file = "DNCodes.csv")
```
#Importing Corrected Code file (DNCodes) and Species Glossary from Amy
```{r}
intermediate <-
Full_Species_List_Glossary_reference_only_ <- read_excel("Full Species List Glossary (reference only).xlsx")
DNCodes <- read_csv("DNCodes.csv")

names(Full_Species_List_Glossary_reference_only_)

#Renaming columns
SpeciesKey <- Full_Species_List_Glossary_reference_only_ %>% 
  select(1:7) %>% 
  rename(SpeciesCode = 'Species Code (A-Z)',
         NativeStatus = 'Native/Non-Native',
         CommonName = 'Common Name',
         SciName = 'Full Scientific Name (Genus species)')
```
#Create a new joined table (Intermediate) that will have the new standardized information
```{r}

Intermediate <- Spring_Data_raw %>%
  filter(is.na(Date) == FALSE) %>%
  full_join(DNCodes, by = "Code") %>% 
  left_join(SpeciesKey, by = "SpeciesCode") %>% 
  mutate(
    LifeForm = case_when(
          is.na(LifeForm) == FALSE  ~ Lifeform, 
          TRUE ~ as.character(LifeForm)),
    
    SpeciesCode = case_when(
      SpeciesCode == "L" ~ "litter",
      SpeciesCode == "B" ~ "bare ground",
      SpeciesCode == "W" ~ "coarse woody debris",
      SpeciesCode == "F" ~ "fine woody debris",
      SpeciesCode == "R" ~ "rock",
      SpeciesCode == "S" ~ "stem",
      SpeciesCode == "T" ~ "thatch",
      TRUE ~ as.character(SpeciesCode)
      ),
    
    SciName = case_when(
    Type == "Ground" ~ CommonName,
    TRUE ~ as.character(SciName)
    )
  ) %>%
  select(-Code) %>%
  fill(Transect) %>%
  select(-Notes) %>%
  select(-LifeForm) %>% 
  mutate(Hits = coalesce(Hits,1))

Intermediate <- Intermediate %>%
  mutate(Transect = factor(Transect))
```

```{r}
#Priscilla's note-filled things

#names() function provides you the column names of your dataframe of interest
names(Full_Species_List_Glossary_reference_only)

```
#More Data Sleuthing
## Example for Transect Column
```{r}
#Find errors - identify unique values
Intermediate$Transect %>% unique()

#There are NAs in the Transect column. Find NAs (filter data for when NA is true).
Intermediate %>% filter(is.na(Transect) == TRUE)

#After looking back at the raw data for this instance, we determine that the NA is a result of the observer not recording the transect value. We can easily see that it is supposed to match the value of data row above it
#fill() will take the value from the data row above to populate the missing NA cell
#solution = line 160
```
#Data Sleuthing - Hits
```{R}
Intermediate$Hits %>% unique ()
Intermediate %>% filter(is.na(Hits) == TRUE)
#Hits - need to replace NAs to 1; because each species was hit at least once
#solution = line 161
```
#Data Sleuthing - Block
```{R}
Intermediate$Block %>% unique()
#no changes necessary
```
#Data Sleuthing - Plot
```{R}
Intermediate$Plot %>% unique()
#no changes necessary
```
#Data Sleuthing - Type
```{R}
Intermediate$Type %>% unique()
Intermediate %>% filter(is.na(Type) == TRUE)
#completely missing species code data for a lot of 2020 data - was this not entered at all? No, it just didn't import properly and I have no idea how to solve this...
```
#Data Sleuthing - SpeciesCode
```{R}
Intermediate$SpeciesCode %>% unique()
Intermediate %>% filter(is.na(SpeciesCode) == TRUE)
#completely missing species code data for a lot of 2020 data - was this not entered at all? No, it just didn't import properly and I have no idea how to solve this...
```